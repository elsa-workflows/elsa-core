using Elsa.Workflows.Core.Attributes;
using Elsa.Workflows.Core.Models;
using Elsa.Workflows.Core.Services;

namespace Elsa.Workflows.Core.Activities;

[Activity("Elsa", "Control Flow", "Schedule an activity for each item in parallel.")]
public class ParallelForEach<T> : Activity
{
    private const string CollectedCountProperty = nameof(CollectedCountProperty);
    [Input] public Input<ICollection<T>> Items { get; set; } = new(Array.Empty<T>());
    [Outbound] public IActivity Body { get; set; } = default!;
    public Variable<T> CurrentValue { get; set; } = new();

    protected override void Execute(ActivityExecutionContext context)
    {
        // Declare looping variable.
        context.ExpressionExecutionContext.Register.Declare(CurrentValue);
        var items = context.Get(Items)!.Reverse().ToList();

        foreach (var item in items)
        {
            var localVariable = new Variable<T>(item)
            {
                // "Capture" the CurrentValues variable by use same ID so that outer scope variable can access inner scope variable.
                Id = CurrentValue.Id
            };
            
            // Schedule a body of work for each item.
            context.ScheduleActivity(Body, OnChildCompleted, new[]{localVariable});
        }
    }

    private ValueTask OnChildCompleted(ActivityExecutionContext context, ActivityExecutionContext childContext)
    {
        var itemCount = context.Get(Items)!.Count;
        var collectedCount = context.UpdateProperty<int>(CollectedCountProperty, count => count + 1);
            
        // Prevent next sibling from executing while not all scheduled activities have completed.
        if(collectedCount < itemCount)
            context.PreventContinuation();
            
        return ValueTask.CompletedTask;
    }
}